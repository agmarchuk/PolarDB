
### 20190111 21:02
Вот решил и дневник перенести в удобное мето. Потом просто скомбинирую файлы и помещу туда, куда надо.

Сейчас надо "приделать" шкалу. Посмотрю как это делалось ранее. 

Какую-то шкалу "приделал", надо испытать. Сначала без шкалы на домашнем компьютере. Загрузк 9.4 сек., выборка 862 / 10 тыс.

Похоже, сработало. Загрузка 10.3 сек., выборка 121 / 10 тыс. Без загрузки, но с подготовкой Prepare() выборка 141, 127 / 10 тыс. Prepare на 10 млн. выполнялась 1.3 сек. 

### 20190112 11:58
Что-то получилось и это хорошо. Однако я понял, что пошел по ложному пути в конструировании индекса. Думаю, все должно быть проще и эффективнее. Надо делать индекс не из абстактных элементов, а ключа и офсета. Потом добавить шкалу. Соответственно, конструктор должен иметь возможность порождать последовательности. Кстати, генератор там уже есть. А вот keyProducer не нужен. В общем, надо перерабатывать.   

Начал энергично перерабатывать и "уперся" в то, что общую конструкцию я упустил и пришлось сходить погулять для того, чтобы подумать. Размышления привели к следующему. Совсем индивидуально работать с каждым индексом не получится - есть всякие общие действия, типа добавления элемента, их надо отрабатывать через общий вызов. С другой стороны, в индексе максимум фиксируются ключ (полуключ) и офсет добавленного элемента. Так что неизбежно надо задавать функцию ключа, но также видимо и полуключа (это потом). Кроме того, в некоторых случаях (View, Halfkey) и для сортировки и для поиска надо привлекать опорную последовательность. Так что надо ее восстановить. С опорной последовательностью есть такая "загвоздка", что на этапе формирования индекса, она может быть не достаточно вычислена. Попробую по-новой.

Итак, судя по интерфейсу IIndex, есть ссылка на опорную последовательность, есть одна или две функции, вычисляющие ключ, а если требуется и полуключ, используя задаваемую Hash-функцию. Индекс может быть полностью очищен Clear() и построен. Построение делается вызовом Build()
