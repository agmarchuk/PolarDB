
Комментарии к решению Main10

Цель эксперимента - сделать эффективный индекс для триплетов. Основу решения возьму ту, которую делал ранее. 

UniversalSequence - основа многих решений. В спецификации имеется тип параметр T. Это тип ключа (или полуключа) Соответственно, именно 
этот класс решений нас интересует в первую очередь. Например, пусть есть последовательность триплетов. Попробуем умозрительно построить
индекс spo. 

Придумал и частично реализовал следующую конструкцию: вводится класс UniversalSequenceBase. Это просто последовательность элементов, 
возможность обнуления, добавления, выборки, перебора. Также вводятся классы, на основе которых можно строить сортировочные индексы. Это 
UniversalSequence<T> - для построения ключевых последовательностей, UniversalSequenceComp, последовательность, сортирующая и ищущая на
основе компаратора. Обе они наследуются от базовой последовательности.

Работаю на компараторной последовательностью. В конструктуре появляется добавление компаратора. Далее идет заполнение. Это делается 
базовыми средствами. Далее идет сортировка. Сейчас сделаю сортировку через ОЗУ.

Не сделал. Меня смущает то обстоятельство, что сортировка, как и поиск не является локальной операцией для индексного построения. Для 
случая без ключа-полуключа, также как и для случая полуключа, в сортировку вовлекается и опорная таблица. В принципе, в этом ничего 
экстраординарного нет, но "чистота" функции "хромает". Все же попробую сделать по "view" - через обращение к значению опорной таблицы. 
Компаратор, в своей концовке, должен сравнивать два объектных представления триплетов. До этого, надо получить объекное представление 
элемента индексной последовательности, т.е. оффсет, по нему "заглянуть" в опорную таблицу, получать объектное представление триплета и
потом его использовать. А что надо делать с поиском? Там у нас сравнение с тремя полями. В зависимости от маски поиска, все поля будут
заполнены или часть полей будет null. Пожалуй, сделаю еще одну попытку поставить эксперимент.

20180124 18:22
Что-то я напортачил. Надо попробовать сконцентрироваться. Идея заключается в том, что простая последовательность будет UniversalSequenceBase.
Она же будет опорной таблицей. Соотвественно, индексная таблица будет UnitedSequenceComp. Она будет содержать ссылку на опорную таблицу.
Соответственно, сортировку делаем для таблицы с компаратором.

Предположу, что заполняю базовую последовательность. Одновременно, буду заполнять и индекс. Индекс получается не какой попало, а 
последовательность или только офсетов или офсетов и полуключей или фосетов и ключей. Для начала, можно "спрятать" эту вариабельнсть 
через фукцию ключа/полуключа. Но до этого, попробую сделать самый общий случай, когда индекс - это последовательность только офсетов.

Перейдем к эксперименту. 

20180127 17:13
С каким-то напрягом идет работа над новыми индексами. Вот наконец сделал View-индекс и GetAny и GetAll методы. Результаты были более или 
менее предсказуемы. 193 мс. - любое, 220 - все.

Теперь надр сделать полуиндекс. Как-то это по-другому хочется оформить. По сравнению со сделанным варинатом, надо явно определить ключевую 
функцию и видимо сортировочный массив надо переделать. 

Что добавляется: добавляется ключ (или полуключ). Соответственно, добавляется ключевая функция. Все это можно внести прямо в UniversalSequenceComp.
Как различать? Если ключевая функция есть - один вариант, нет - другой. Попробую.

20180128 10:11
Начал реализацию "полуключевого" подхода. Пытаюсь четка сформулировать идейную канву подхода. 

UniversalSequenceCompKey32 - универсальная последовательность, имеющая целый полуключ и компаратор. В рабочем состоянии, каждому элементу 
опорной (bearing) последовательности сопоставляется поляровская запись ключ-офсет и эти элементы отсортированы по компаратору. Ключ создается 
из объектного представления элемента последовательности примерением ключевой функции и является основной частью сравнения. Компаратор сравнивает 
объекты при совпадении ключа.

Соответственно, пришлось сделать специальный компаратор DoubleComparer32, который производит двойное сравнение. Но есть нюанс, о котором я сейчас
думаю. Дело в том, что для экономности, желательно делать такую реализацию пар ключ-объект, что вместо объекта объекта может быть null. Это сильно 
экономит и память и доступ к диску для случаев хорошего покрытия хеш-функцией значений сравнимаемых объектов. 

Вся эта схема нужна для решения двух вопросов. Первый - сортировка. Здесь решение с закачиванием пар (ключ-объект) кажется излишне громоздким.
Есть два варианта как это экономнее сделать. Можно расчитывать на то, что сравнимых вариантов при одинаковом ключе мало. И тогда сортировать 
в основном через массив ключей, иногда обращаясь в опорным значениям для "уточнения". Можно вообще отсортировать только по ключу и все 
"недоразумения" разгребать в динамике использования. Можно сначала массив отсортировать по ключу, потом одинаковые подмассивы сортировать 
дополнительно по объектам. Попробую сделать этим способом. 

20180130 03:38
Удалось сделать вариант хранилища триплетов с полуключем. Это значит, что в виде индексного построения сохраняется множество пар (ключ, офсет).
Причем "ключ" - это некоторое отображение значения опорной таблицы на целое значение. Индекс сортируется в две ступени, сначала по ключу, потом
по функции сравнения. Соответственно, бинарный поиск осуществляется с применением фнукции "двойного" сравнения: сначала идет сравнение по ключу,
а если совпадает - по компаратору. Это "запускает" компаратор не так часто и удается получить время поиска 131 мс. на 1000 запросов. Это по
вычислению потока офсетов, а поток объектов вычисляется 200 мс. на 1 тыс. Не слишком хорошо, но все же. Бинарный поиск можно улучшить, если 
применить шкалу. Если будет построена шкала, то быстрым действием, мы получаем диапазон основного массива в котором находится искомое решение. 

Проблема заключается в том, что шкала (пока) строится для массива ключей. Но где-то массив у нас имеется, можно попробовать...

Вроде получилось. Получилось 42-43 мс. на тысячу. Это уже лучше!

