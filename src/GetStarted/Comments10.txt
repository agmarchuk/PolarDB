
Комментарии к решению Main10

Цель эксперимента - сделать эффективный индекс для триплетов. Основу решения возьму ту, которую делал ранее. 

UniversalSequence - основа многих решений. В спецификации имеется тип параметр T. Это тип ключа (или полуключа) Соответственно, именно 
этот класс решений нас интересует в первую очередь. Например, пусть есть последовательность триплетов. Попробуем умозрительно построить
индекс spo. 

Придумал и частично реализовал следующую конструкцию: вводится класс UniversalSequenceBase. Это просто последовательность элементов, 
возможность обнуления, добавления, выборки, перебора. Также вводятся классы, на основе которых можно строить сортировочные индексы. Это 
UniversalSequence<T> - для построения ключевых последовательностей, UniversalSequenceComp, последовательность, сортирующая и ищущая на
основе компаратора. Обе они наследуются от базовой последовательности.

Работаю на компараторной последовательностью. В конструктуре появляется добавление компаратора. Далее идет заполнение. Это делается 
базовыми средствами. Далее идет сортировка. Сейчас сделаю сортировку через ОЗУ.

Не сделал. Меня смущает то обстоятельство, что сортировка, как и поиск не является локальной операцией для индексного построения. Для 
случая без ключа-полуключа, также как и для случая полуключа, в сортировку вовлекается и опорная таблица. В принципе, в этом ничего 
экстраординарного нет, но "чистота" функции "хромает". Все же попробую сделать по "view" - через обращение к значению опорной таблицы. 
Компаратор, в своей концовке, должен сравнивать два объектных представления триплетов. До этого, надо получить объекное представление 
элемента индексной последовательности, т.е. оффсет, по нему "заглянуть" в опорную таблицу, получать объектное представление триплета и
потом его использовать. А что надо делать с поиском? Там у нас сравнение с тремя полями. В зависимости от маски поиска, все поля будут
заполнены или часть полей будет null. Пожалуй, сделаю еще одну попытку поставить эксперимент.

20180124 18:22
Что-то я напортачил. Надо попробовать сконцентрироваться. Идея заключается в том, что простая последовательность будет UniversalSequenceBase.
Она же будет опорной таблицей. Соотвественно, индексная таблица будет UnitedSequenceComp. Она будет содержать ссылку на опорную таблицу.
Соответственно, сортировку делаем для таблицы с компаратором.

Предположу, что заполняю базовую последовательность. Одновременно, буду заполнять и индекс. Индекс получается не какой попало, а 
последовательность или только офсетов или офсетов и полуключей или фосетов и ключей. Для начала, можно "спрятать" эту вариабельнсть 
через фукцию ключа/полуключа. Но до этого, попробую сделать самый общий случай, когда индекс - это последовательность только офсетов.

Перейдем к эксперименту. 