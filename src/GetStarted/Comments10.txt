
Комментарии к решению Main10

Цель эксперимента - сделать эффективный индекс для триплетов. Основу решения возьму ту, которую делал ранее. 

UniversalSequence - основа многих решений. В спецификации имеется тип параметр T. Это тип ключа (или полуключа) Соответственно, именно 
этот класс решений нас интересует в первую очередь. Например, пусть есть последовательность триплетов. Попробуем умозрительно построить
индекс spo. 

Придумал и частично реализовал следующую конструкцию: вводится класс UniversalSequenceBase. Это просто последовательность элементов, 
возможность обнуления, добавления, выборки, перебора. Также вводятся классы, на основе которых можно строить сортировочные индексы. Это 
UniversalSequence<T> - для построения ключевых последовательностей, UniversalSequenceComp, последовательность, сортирующая и ищущая на
основе компаратора. Обе они наследуются от базовой последовательности.

Работаю на компараторной последовательностью. В конструктуре появляется добавление компаратора. Далее идет заполнение. Это делается 
базовыми средствами. Далее идет сортировка. Сейчас сделаю сортировку через ОЗУ.

Не сделал. Меня смущает то обстоятельство, что сортировка, как и поиск не является локальной операцией для индексного построения. Для 
случая без ключа-полуключа, также как и для случая полуключа, в сортировку вовлекается и опорная таблица. В принципе, в этом ничего 
экстраординарного нет, но "чистота" функции "хромает". Все же попробую сделать по "view" - через обращение к значению опорной таблицы. 
Компаратор, в своей концовке, должен сравнивать два объектных представления триплетов. До этого, надо получить объекное представление 
элемента индексной последовательности, т.е. оффсет, по нему "заглянуть" в опорную таблицу, получать объектное представление триплета и
потом его использовать. А что надо делать с поиском? Там у нас сравнение с тремя полями. В зависимости от маски поиска, все поля будут
заполнены или часть полей будет null. Пожалуй, сделаю еще одну попытку поставить эксперимент.

20180124 18:22
Что-то я напортачил. Надо попробовать сконцентрироваться. Идея заключается в том, что простая последовательность будет UniversalSequenceBase.
Она же будет опорной таблицей. Соотвественно, индексная таблица будет UnitedSequenceComp. Она будет содержать ссылку на опорную таблицу.
Соответственно, сортировку делаем для таблицы с компаратором.

Предположу, что заполняю базовую последовательность. Одновременно, буду заполнять и индекс. Индекс получается не какой попало, а 
последовательность или только офсетов или офсетов и полуключей или фосетов и ключей. Для начала, можно "спрятать" эту вариабельнсть 
через фукцию ключа/полуключа. Но до этого, попробую сделать самый общий случай, когда индекс - это последовательность только офсетов.

Перейдем к эксперименту. 

20180127 17:13
С каким-то напрягом идет работа над новыми индексами. Вот наконец сделал View-индекс и GetAny и GetAll методы. Результаты были более или 
менее предсказуемы. 193 мс. - любое, 220 - все.

Теперь надр сделать полуиндекс. Как-то это по-другому хочется оформить. По сравнению со сделанным варинатом, надо явно определить ключевую 
функцию и видимо сортировочный массив надо переделать. 

Что добавляется: добавляется ключ (или полуключ). Соответственно, добавляется ключевая функция. Все это можно внести прямо в UniversalSequenceComp.
Как различать? Если ключевая функция есть - один вариант, нет - другой. Попробую.

20180128 10:11
Начал реализацию "полуключевого" подхода. Пытаюсь четка сформулировать идейную канву подхода. 

UniversalSequenceCompKey32 - универсальная последовательность, имеющая целый полуключ и компаратор. В рабочем состоянии, каждому элементу 
опорной (bearing) последовательности сопоставляется поляровская запись ключ-офсет и эти элементы отсортированы по компаратору. Ключ создается 
из объектного представления элемента последовательности примерением ключевой функции и является основной частью сравнения. Компаратор сравнивает 
объекты при совпадении ключа.

Соответственно, пришлось сделать специальный компаратор DoubleComparer32, который производит двойное сравнение. Но есть нюанс, о котором я сейчас
думаю. Дело в том, что для экономности, желательно делать такую реализацию пар ключ-объект, что вместо объекта объекта может быть null. Это сильно 
экономит и память и доступ к диску для случаев хорошего покрытия хеш-функцией значений сравнимаемых объектов. 

Вся эта схема нужна для решения двух вопросов. Первый - сортировка. Здесь решение с закачиванием пар (ключ-объект) кажется излишне громоздким.
Есть два варианта как это экономнее сделать. Можно расчитывать на то, что сравнимых вариантов при одинаковом ключе мало. И тогда сортировать 
в основном через массив ключей, иногда обращаясь в опорным значениям для "уточнения". Можно вообще отсортировать только по ключу и все 
"недоразумения" разгребать в динамике использования. Можно сначала массив отсортировать по ключу, потом одинаковые подмассивы сортировать 
дополнительно по объектам. Попробую сделать этим способом. 

20180130 03:38
Удалось сделать вариант хранилища триплетов с полуключем. Это значит, что в виде индексного построения сохраняется множество пар (ключ, офсет).
Причем "ключ" - это некоторое отображение значения опорной таблицы на целое значение. Индекс сортируется в две ступени, сначала по ключу, потом
по функции сравнения. Соответственно, бинарный поиск осуществляется с применением фнукции "двойного" сравнения: сначала идет сравнение по ключу,
а если совпадает - по компаратору. Это "запускает" компаратор не так часто и удается получить время поиска 131 мс. на 1000 запросов. Это по
вычислению потока офсетов, а поток объектов вычисляется 200 мс. на 1 тыс. Не слишком хорошо, но все же. Бинарный поиск можно улучшить, если 
применить шкалу. Если будет построена шкала, то быстрым действием, мы получаем диапазон основного массива в котором находится искомое решение. 

Проблема заключается в том, что шкала (пока) строится для массива ключей. Но где-то массив у нас имеется, можно попробовать...

Вроде получилось. Получилось 42-43 мс. на тысячу. Это уже лучше! 34 мс. на рабочем компьютере. Правда загрузка увеличивается до 6.8 сек.
попробую сделать расчеты на больших объемах. 
1 млн. 6.8 сек., 34 мс. / 1000
10 млн. 69 сек., 58
100 млн. 870 сек., 163 мс.
Количество триплетов удваивается, последняя цифра касается 200 млн. триплетов. Оперативной памяти использовалось относительно немного. ТО, что 
видел - около 4-5 Гб. 

Теперь попробую сделать расчеты без загрузки.
1 млн. 32 мс. /1000 - это потому, что шкала не активирована
10 млн. загрузка шкалы 5.1 сек., 33 мс.
100 млн. 51 сек., 49 мс.

В общем - все в порядке. Хорошо бы загружать несколько быстрее.

Сделал изменение и сразу появилась непонятность. Изменение в том, что локальную сортировку я теперь заказал делать только если длина
локального участка больше 1. Загрузка стала выполняться быстрее
1 млн. 1.6 сек., 32 мс.
Но почему? Вроде все субъекты повторяются по 2 раза.  

Разобрался, исправил ошибку, которая в данном случае не приводила к проблемам. И нашел способ ускорить загрузку. Суть способа в том,
что локальную сортировку я делаю если число элементов в локальной группе больше 39. Соответственно, этот случай выполняется перебором
в методе выборки BinarySearchAll для для групп менее 40 элементов. Правда могуть быть или не быть перекрытия. Надо бы эти свойства доказать.

А пока получилось:
зарузка, выборка, построение шкалы, выборка
1 млн. 1.7 с., 32, 0.5 с., 33
10 млн. 17 с., 33, 5 с., 33
100 млн. 436 с., 42, 52 с., 36

Пока хватит.

Теперь надо бы сделать общую схему для такого индекса. Общая схема видится в том, что ключ становится 64-разрядным числом, разбитым на 
несколько полей. Поле субъекта, поле предката, поле объекта. На поле субъекта выделяется 24 бита, на поле предиката 8 битов, на поле 
объекта 31-32 бита. Поле объекта состоит из поля варианта 4 бита, и поле подзначения 27-28 битов. Поле подзначения может быть:
IRI - тогда это сплошное целое значение, может быть типизированной текстовой константой IRI-типа + текстовое значение - 8+20, могут быть 
разные зафиксированные варианты типов (целое, вещественное и др.), может быть языковая константа, здась возможно правильно было бы
20+8, но может надо как в типизованной константе. 

Подумаю об абстракции, которая может быть положена в основу разных решений. Идея заключается в том, что целый, возможно длиныый ключ 
разбивается на части, работающие по старшинству - сначала более старшие, потом по нисходящей. 