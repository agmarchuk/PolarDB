
### 20190326 07:40
Решил, что писать программу в одном решении, а вести дневник в другом - неудобно, попробую приближать записи дневника к 
разрабатываемым. 

Итак, вчера я вышел на решение поиска по объекту. По крайней мере, показываются результаты, соответствующие ожиданиям. 
Теперь надо довести их до правильных. Кажется, для этого надо сформулировать компаратор и запустить его в работу. Снова 
проговорю логику работы индекса, работающего по полуключу. Есть множество элементов, на элементах задана ключевая функция
и согласованный с ней компаратор. Компаратор более "тонкий" инстумент, т.е. если значения ключей элементов различаются, то
в этом же направлении различаются и значения компаратора, но не наоборот.

Индексная структура формируется как множество пар (ключ, элемент) или (ключ, офсет(элемента)). Эта индексная структура 
отсортирована по ключу и по компаратору. Поиск по образцу заключается в том, что предъявляется образец, по нему вычисляются
все элементы, которые с образцом совпадают по компаратору (а значит, и по ключу). Это можно делать в два этапа. 
Сначала выделить диапазон, в котором тот же ключ. А потом в этом диапазоне проивести линейный или бинартный поиск.

Есть еще один вопрос для будущего, как учесть в индексе динамику изменений опорной последовательности? Не получается вариант 
с добавляемыми парами (ключ-значение). Предположение заключается в том, что в качестве динамической части индексного построения,
можно использовать что-нибудь вроде SortedSet<T>. Вроде все там в порядке и даже компаратор можно задать, но не очевидна 
сложность добавления элементов. Соответственно, мы новые элементы можем добавлять, а потом с ними сравнивать.

Я еще подумал. Вроде SortedSet не подходит. Нужен какой-то отсортированный по компаратору список элементов. Причем сравнение 
элементов может быть и нулевым. Чтобы к списку можно было бы легко добавлять элементы, не изменяя его отсортированности. Далее,
задается (конкретный) предикат, согласованный с компаратором. Требуется найти все элементы, удовлетворяющие предикату. Как эта 
задача решается? Предикат - это функция. Пусть задается "уровень" - функция, которая < 0 на "левых" элементах, = 0 на 
"центральных" элементах и > 0 на правых. Центральные и есть решение задачи. 

Запутался в логике построения ключевого индекса IndexKey32CompImm. Причем запутался в том месте, когда начинает использоваться 
компаратор. Логика построения такова: есть опорная последовательность и именно к ней строится индекс. Для этого, определяется 
функция ключа и строится набор пар {ключ, офсет}. Дальше массив сортируется, первично - по ключу, вторично - по компаратору. 
Компаратор сравнивает два объекта, соответствующих элементам опорной последовательности. Причем сначала сравнение идет по ключу,
а вторично - с помощью компаратора. 

### 20190327 06:53
Так вчера и не "распутался". Есть проблемы с сортировкой по полуключу. Есть проблемы с выборкой по ключу. Итак, вернусь
к конструкции. Есть опорная последовательность элементов. На ней задан ключ (полуключ). Формируется последовательность пар 
ключ-офсет и сортируется по ключу, вторичная сортировка производится по компаратору. Компаратар задан на объектном представлении
элементов опорной последовательности. Поэтому объекты компарации формируются из пары ключ-офсет через чтение из опорной таблицы 
объекта по офсету. 

Теперь о выборке. Есть простая выборка по ключу. Это хорошо работает когда нет компаратора. Предположим, мы можем сформировать
элемент-образец. Тогда мы можем ставить задачу выборки всех элементов из опорной последовательности, "эквивалентых" образцу
по компарации. Но это - "точная" выюборка. Можно попробовать так и сделать. Алгоритм следующий. Мы образец используем в делении
отрезка пополам и, с помощью компаратора, находим ноль, одно или более решение, удовлетворяющее условию сравнения. Этим у меня
занимается некоторая рекурсивная процедура. Процедура есть, но она не сформирована для работы с компаратором. Попробую это 
изменить. 

Сейчас поменял реализацию для нахождения всех записей по заданному ключу. Выборка ускорилась почти в 2 раза! Теперь по субъекту
получаем 1000 запросов за 8 мс. (77 мс. на 10 тыс. запросов). Внимательно посмотрев, я выяснил, что сделал не то. Я вопосльзовался 
массивом пар, расположенным в ОЗУ. Надо применить другое решение. Кстати, хорошо бы иметь понятный и эффективный интерфейс. Для
отдельного инедекса, это взятие всех решений по образцу. Но по образцу чего? Самый "универсальный" вариант - по "образцу" элемента.
Или по образцу объекта (или субъекта), который позволяет что-то. Наверное, на уровне индексного построения, когда у нас есть
ключевая функция и компаратор, правильнее будет подавать псевдоэлемент. Попробую.

Вернул характеристики на 14 мс. за 1000 выборок. Это по субъекту. Теперь буду работать по выборке по объекту. Буду работать 
поэтапно. Сначала только по ключу: сортировка и выборка. Потом подключаем компаратор, опять же: сортировка и выборка. Потом 
выборка по "похожему" значению. 

### 20190329 06:37
Вчера засуетился, много чего сделал, а вот проектом не занимался. Как-то надо исправлять ситуацию, тем более, что просыпаясь, 
я думаю об алгоритмах и логике. "Открытием" последних дней оказалось осознание того, что словарь "ключ-офсет" не является 
универсальным решением для выстраивания динамической части индекса. Видно, что надо использовать что-то вроде SortedTree, но 
такого класса в стандартной библиотеке нет. Возможно, в динамической части индекса лучше оказаться от сортировки и пользоваться 
простым List<T> или LinkedList<T>. Или делать двухуровневую динамику, когда есть напр. SortedList и есть List. Правда SortedList
обладает двумя недостатками. Во-первых - это key-value коллекция. Во-вторых - ключи не могут повторяться, но наверное, это 
следствие первого свойства. 

Вернусь к тому, что надо делать прямо сейчас. Сейчас я работаю над полуключевым индексом. Первое действие, надо существенно 
ускорить сортировку. Идея естественная: сначала пары сортирую по ключу, потом для каждого ключа, идет выделение множества
элементов опорной последовательности и производится сортировка по компаратору. После этого, все пары переписываются из массива
в последовательность. Действую.

18:27

Еще утром сделал двухуровневую сортировку. Построение Build() индекса происходит за 900 мс. (1 млн. триплетов). Теперь 
буду пробовать правильно сделать поиск. 

### 20190330 08:15
Наконец, заработали решения построения индекса на основе ключа и полуключа. В тесте, индекс по субъекту строится на основе 
ключа, индекс по объекту строится на основе полуключа. Для 1 млн. триплетов, оба индекса строятся 4.3 сек., 1000 выборок 
для ключа выполняется 14 мс., для полуключа - 107 мс. В принципе, это не так плохо.

Попробую пропустить тесты на больших размерах данных. 

1 млн. 4.3 сек., 14, 107
10 млн. 47 сек., 27, 151
100 млн. 
