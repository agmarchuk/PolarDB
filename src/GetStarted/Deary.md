
### 20190326 07:40
Решил, что писать программу в одном решении, а вести дневник в другом - неудобно, попробую приближать записи дневника к 
разрабатываемым. 

Итак, вчера я вышел на решение поиска по объекту. По крайней мере, показываются результаты, соответствующие ожиданиям. 
Теперь надо довести их до правильных. Кажется, для этого надо сформулировать компаратор и запустить его в работу. Снова 
проговорю логику работы индекса, работающего по полуключу. Есть множество элементов, на элементах задана ключевая функция
и согласованный с ней компаратор. Компаратор более "тонкий" инстумент, т.е. если значения ключей элементов различаются, то
в этом же направлении различаются и значения компаратора, но не наоборот.

Индексная структура формируется как множество пар (ключ, элемент) или (ключ, офсет(элемента)). Эта индексная структура 
отсортирована по ключу и по компаратору. Поиск по образцу заключается в том, что предъявляется образец, по нему вычисляются
все элементы, которые с образцом совпадают по компаратору (а значит, и по ключу). Это можно делать в два этапа. 
Сначала выделить диапазон, в котором тот же ключ. А потом в этом диапазоне проивести линейный или бинартный поиск.

Есть еще один вопрос для будущего, как учесть в индексе динамику изменений опорной последовательности? Не получается вариант 
с добавляемыми парами (ключ-значение). Предположение заключается в том, что в качестве динамической части индексного построения,
можно использовать что-нибудь вроде SortedSet<T>. Вроде все там в порядке и даже компаратор можно задать, но не очевидна 
сложность добавления элементов. Соответственно, мы новые элементы можем добавлять, а потом с ними сравнивать.

Я еще подумал. Вроде SortedSet не подходит. Нужен какой-то отсортированный по компаратору список элементов. Причем сравнение 
элементов может быть и нулевым. Чтобы к списку можно было бы легко добавлять элементы, не изменяя его отсортированности. Далее,
задается (конкретный) предикат, согласованный с компаратором. Требуется найти все элементы, удовлетворяющие предикату. Как эта 
задача решается? Предикат - это функция. Пусть задается "уровень" - функция, которая < 0 на "левых" элементах, = 0 на 
"центральных" элементах и > 0 на правых. Центральные и есть решение задачи. 
