В библиотеке классов Indexes сгруппированы решения по построению индексов для баз данных, а также для построения 
key-value хранилищ или таблиц имен. 

В составе библиотеки:


Некоторую центральную роль библиотеки играет универсальный индекс

### Универсальный индекс

Универсальный индекс создается для (опорной) последовательности элементов типа T.
Последовательность реализуется ячейкой PaCell, что позволяет быстро
- заполнять последовательность элементами
- добавлять элементы
- сканировать элементы.

Если модифицировать последовательность до последовательности, хранящей элементы вида w = {d:boolean, v:T}, где d (deleted) - признак "уничтоженности" элемента, то набор действий расширяется. Также эффективно можно выполнять операцию "уничтожить" путем выставления признака в истину.

Пока не было никаких индексов. И никаких словарей! Все только используя ячейку.

Пусть имеется функция ключа K(v), задающая порядок. Соответственно, в простом случае, ставится задача по известному ключу key находить все значения v такие, что K(v) = key. Задача решается через создание другой последовательности (массива) пар {key, offset(w)}. Эта последовательность сортируется и по ней можно находить нужную группу решений, которые фильтруются на предмет уничтоженности. 

Заметим, что индексный массив вычисляется по заданной опорной последовательности в любой момент времени. К индекному массиву добавим словарь Dictionary<K,longint> или Dictionary<K,List<longint>> в зависимости от однозначности или неоднозначности множества ключей. В словарь под соответствующими ключами будем помещать офсеты значений, по которым доступны значения w.

К опорной таблице дополнительно приделаем список индексов, заведенных для этой таблицы. Также модифицируем метод добавления элемента в опорную таблицу таким образом, что сначала элемент добавляется, а потом для каждого индекса сообщается о том, что элемент добавлен. Индексы отрабатывают это сообщение тем, что можифицируют свои динамические части, т.е. словари. 


