## Изучаем
Раздел дает возможность изучить основные элементы и свойства технологии Поляр.

### Концепция
#### Идея проекта

Идея проекта в том, чтобы сформировать систему согласованных эффективных решений (библиотеку) для построения сосредоточенных или распределенных специализированных баз данных и СУБД.  

#### Термины и определения

**Структурное значение** (structured value, поляровское структурное значение, p-value) - древовидное построение (значение), интерпретируемое в соответствии с заданным типом.

**Тип** (Type, поляровский тип, p-type) - древовидное построение, задающее интерпретацию для структурных значений. Может быть выражено как структурное значение. Тип может быть примитивным (атомарным) или конструируемым (составным).

**Объект базы данных** - сформированное в некотором рабочем поле или в хранилище структурное значение.

**Объектное представление** структурного значения - внутренняя конструкция в ОЗУ, вместе с типовым значением, задающая структурное значение. Объектное представление реализуется средствами какой-то (напр. .NET) системы программирования, доступно через какой-то язык программирования и служит связующим средством между программными объектами и объектами базы данных по следующей схеме: объект базы данных полностью или частично, отдельными полями, может быть реализован значениями объектного представления. Соответственно, возможно "чтение" объектов базы данных или их полей в объектное представление. И наоборот, возможна "запись" значений объектного представления в объекты базы данных или их поля.   
 
**Текстовая сериализация** (текстовое представление) структурного значения - точные правила представления любого структурного значения последовательностью символов. Текстовое представление, совместно с явно или неявно определенным типом этого представления, есть структурное значение 

**Бинарная (байтовая) сериализация** структурного значения - правила представления любого структурного значения в виде потока байтов. Бинарная сериализация осуществляется только в контексте типа сериализуемого или десериализуемого структурного значения.   

#### Начальные спецификации

Примитивные типы:
- boolean, character, integer, longinteger, real - логическое, символьное, целое (32 разряда), длинное целое (64 разряда), число с плавающей точкой (64 разряда),
- @byte - байт - 8-разрядный код, 
- none - множество значений, не содержащее ни одного элемента,
- sstring - обычные строки объектно-ориентированного программирования (C#).

Конструируемые типы: 
- Запись (record) - фиксированный набор типизированных полей. Есть поля 0, 1, ... n-1, каждое из которых представляет значение заданного в определении записи типа. Количество полей - фиксировано, типы полей - фиксированы. Иногда полям сопоставляют имена, являющиеся идентификаторами. 
- Последовательность (sequence) - упорядоченный набор, состоящий из неопределенного (ноль или более) числа однотипных 
элементов. 
- Объединение (union) - значение, состоящее из тега и подзначения. Тег (динамически) определяет вариант типа для подзначения. Теги нумеруются, начиная с 0.

Объектное представление. Любое структурное значение может быть представлено в виде объекта по следующей схеме: примитивные типы реализуются значениями соответствующих системных типов - логического, целого, длинного целого, с плавающей точкой (double), символьного (char), байта, строки. Значения типа none представляются значениями null. Конструируемые типы представляются массивами object[], элементами которых будут подзначения структур. Запись - массив объектных значений своих элементов, последовательность - массив объектных значений элементов. Значение объединенного типа представляет собой массив из двух элементов. Первый элемент - целое значение тега. Второй элемент - объектное представление подзначения соответствующего тегу типа. 

Примеры. Объектные значения (object)22, (object)"demo string", (object)true могут быть проинтерпретированы только как целое, строка и логическое. Объект new object[] {2, 33} может быт проинтерпретирован в зависимости от типа или как запись двух целых или как последовательность целых или как объединение с вариантом 2 и подзначением 33. Для последовательности записей, состоящих из строкового и целого, значением в объектном представлении может быть:
new object { new object[] {"str1", 111}, new object[] {"str2", 222} }        
 
Текстовая сериализация. Атомарные значения изображаются в виде текста: типа none - пустой строкой, типа boolean, character, integer, longinteger, real - традиционно, как напр. в C#. @byte изображается 16-ричным кодом, строка - как обычно (в C#). Запись изображается перечислением через запятую значений всех полей записи, начиная с нулевого и далее по порядку. Возможно использования имен полей (как в Паскале). Последовательность, изображается перечислением элементов через запятую, все перечисление (нуль или более элементов) помещается в квадратные скобки. Объединение изображается тегом - числом в диапазоне 0-255, следующим за ним символом ^ и далее идет изображение значения того типа, который динамически задан тегом. Значение может быть помещено в круглые скобки, это нужно для определенности разбора. По структурному значению и его типу однозначно, с точности до несущественных синтаксических элементов (пробелы, перевод строки, tab) и "лишних" скобок, определяется текстовая развертка. По корректной текстовой развертке и типу, однозначно определяется структурное значение.

Примеры. Для структурного значения типа последовательности записей строкового и целого полей, заданного в объектном виде как new object { new object[] {"str1", 111}, new object[] {"str2", 222} }, текстовая сериализация будет: 
[ {"str1", 111}, {"str2", 222} ]. 



Бинарная сериализация. Бинарная сериализация выполняется следующим образом: атомарные значения отображаются на последовательность байтов так, как определяется системой программирования C# через метод System.IO.BinaryWriter и двойственный ему System.IO.BinaryReader. Байт отображается в байт, целое в 4 байта, длинное целое - в 8 байтов, число с плавающей точкой в 8 байтов, значение типа none - в 0 байтов. Строка отображается сложнее. Сначала идет целое (4 байта) число, равное количеству символов в строке. Далее, если количество символов больше 0, то идут байты, сформированные по правилам UTF-8: byte[] info = new UTF8Encoding(true).GetBytes(str);
Запись сериализуется поставленными "встык" сериализованными значениями полей. Последовательность вначале имеет 64-разрядное (8 байтов) целое, фиксирующее количество элементов последовательности (0+), а за ним подряд идут соответствующее количество значений элементов последовательности. Объединение реализуется постановкой 1 байта, который фиксирует код тега (0-255), за этим байтов непосредственно следует подзначение соответствующего тегу типа.    

Язык определения типов. Поляровские типы задаются некоторыми формулами, задающими типовые (ударение на первый слог) значения. В принципе, эти значения можно рассматривать как обычные структурные значения, но эта ветвь в текущем варианте Поляра не реализована. К тому же, работать с заданием типа в таком представлении неудобно. Поэтому, для наглядности, в иллюстрациях используется специальный язык определения типов. Синтаксис языка в БНФ: 
<pre>
типовое_определение: имя_типа = типовая_формула ;
типовая_формула: none
     | bool | byte | char | int | long | float
     | { (имя поля : )? типовая_формула,.. }
     | [ типовая_формула ]
     | имя_тега ^ типовая формула
</pre>   
Синтаксические особенности и добавления. В формуле определения записи возможно использование имен полей. В случае, когда определяется последовательность записей, фигурные скобки внутри прямоугольных можно опустить. 
        
Ячейка (Cell) - хранилище для структурного значения. Ячейка всегда типизирована и предназначена для хранения значений только данного типа. Ячейка может быть пустой (empty), если она не пустая, она хранит какое-то значение. Ячейка, как правило, связана с файлом или потоком (Stream), в котором и хранится значение. Наиболее интересным видом хранилища, являются потоки прямого доступа, т.е. такие, в которых можно установить указатель чтения на конкретное место потока и произвести чтение или запись. Для ячеек, в качестве базового промежуточного формата, используются объектное представление. Это означает, что часть или целое структурное значение, хранящееся в ячейке, можно прочитать и при этом получить объектное представление. И наоборот, объектное представление можно записать в ячейку или его часть. Обязательным является согласованность типов объектного и бинарного представлений структур. На этом построена логика использования ячейки в качестве хранилища. Универсальный вариант - чтение всего записанного структурного значения. Или его запись. Вариант всегда применим, но проблема в том, что весь объект может быть слишком большим для размещения в оперативной памяти. Такие объекты модифицируются частями, т.е. полями. 

Для выделения и указания поля чтения/записи, введено понятие **входа (Entry)**. По-русски, вероятно, было бы правильно говорить о "точке входа" 


