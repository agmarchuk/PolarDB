# Смотрим в будущее
В разделе сгруппирована информация о планах существенных добавлений, модернизаций и переработок системы. Раздел предназначен для разработчиков Поляра и сопряженных технологий.

### Специальное представление поляровских структур
Два основных способа представления p-значений - объектное и свободный формат в потоке байтов, для многих задач не достаточно хороши. Желательно иметь специальное представление, которое видится следующим образом:
- атомарные значения реализуются атомарными значениями системы программирования (.NET), разница с объектным представлением в том, что они "насильственно" не переводятся в объекты, а по возможности составляют часть внешней записи или структуры;
- структуры делаются как struct, т.е. не ссылочными объектами;
- последовательности реализуются как массивы элементов, как правило - массивы значений, а не ссылок;
- объединения - не знаю.

А еще важно, чтобы массивы были разбиты на подмассивы - это нужно для эффективной загрузки. Проблема состоит в том, что при таком подходе, непонятно как выделять поля. Если бы средой реализации был бы C, там все понятно - ссылка void* и этого достаточно. Но в C# так не получится. А как получится? Возможно, надо делать более "хитрый" объект (поле-тип). Например, поле могло бы быть начальной объектной ссылкой с добавлением цепочки выделений (цепочка целых). Подозреваю, что такой подход будет эффективным только для частных случаев, напр. для цепочек, состоящих из двух элементов. Или цепочки, состоящей из одного индекса - индекса элемента в массиве. 

Последний способ выглядит интересно. Например, мы имеем индексную последовательность пар: ключ-значение. Эта последовательность уложена в поток байтов ячейки стандартным образом. Что нам нужно делать с индексной структурой? Если она отсортирована, то только поисковые или индексные выборки. Вот мы вычисляем указатель на элемент последовательности. Далее следует или Get() или выделение поля, а потом уже Get(). Допустим, мы для этой структуры запрещаем на уровне указателей выделять поля. То есть, конструкцию вида cell.Root.Element(i).Get() или ее эквивалент entry.AtOffset(offset).Get() мы разрешаем, а уточнение вида cell.Root.Element(i).Field(j)... запрещаем. При этом, 
entry.AtOffset(offset).Get() вырабатывает объектное представление, хотя лучше бы запись(!).    
И пусть у нас есть понятие "теневого значения", как массив массивов записей из двух полей. Размер внутреннего массива можно вычислить напр. как длину блока в байтах, деленную на размер записи в байтах. Соответственно, берем последнюю формулу, вычисляем в ней индекс элемента, по индексу элемента, вычисляем номер массива и индекс в массиве, выясняем есть ли массив с указанным номером и если нет, подгружаем его, и наконец, считываем запись и преобразуем или не преобразуем ее в объектное представление. Как-то так...

Возможно, напр. для последовательностей лучше ввести метод типа cell.Root.GetElement(i) и иметь два варианта реализации в зависимости от того есть теневой массив массивов или нет.       

В принципе, любопытно!..

