### Проект Polar.OModel

Начинаю новый проект. Хочу попробовать целостно реализовать концепцию объектной модели последовательности, изложенной в [].
Буду использовать некоторые классы из Polar.DB, если проект получится, то перенесу его именно туда. Итак, начну прямо по тексту
статьи.

Последовательность - это набор объектов. В данном рассмотрении, объекты будут только одного вида: простой объект или массив объектов. 
Возможно, будет иметь смысл ввести тип, напр. RObject, но пока не буду этого делать. Второй момент - объекты предполагаются типизированными 
через систему типов Поляра, а последовательность будет набором элементов одного типа. Типизацию возмем из Polar.DB в виде объектов класса 
PType. Присоединю тот проект к этому. 

В качестве тестового и конкретизирующего материала, использую тип Person. В поляровской системе типизации, определение будет:
```
Person = {id: Int, name: Str, age: Int};
```
Сериализацию берем такой, которая сформирована. Естественно, в реализации баз данных, больше подходит бинарная сериализация. 
Я посмотрел, похоже, класс UniversalSequenceBase нам полностью подходит. Расширение этого класса добавит недостающие методы редактирования.
Итак, что у нас получается? Делаем конструктор, пока повторяющий конструктор базы


Добавляем через конструктор две функции
```
private Func<object, bool> isEmpty;
private Func<object, DateTime> timestamp;
```
Первая указывает на то, что элемент "пустой", т.е. вроде как отсуствующий. Вторая выдает отметку времени данного элемента. 

Далее, надо бы наметить реализацию ввода и сканирования. Уже на сканировании я споткнулся. 
В результирующий поток хотелось бы чтобы попадали последние варианты элементов. Намечу канву: 1) Есть компаратор (ключевой), определяющий
эквивалентноть элементов. 2) Среди эквивалентных элементов оригиналом является элемент с максимальной временной отметкой. 
Базовым решением является перебор элементов последовательности с проверкой является ли данный элемент оригиналом. Для этого, из взятого элемента
извлекается идентификатор, а по этому идентификатору выявляется является ли элемент тем самым. Если "тот самый элемент" имеет отметку пустого, то
он также не выдается в результирующий поток. Проблема данного алгоритма в том, что на каждый элемент базовой последовательности требуется производить поиск.
Можно поступить наоборот, сканировать индексный массив, причем только на отличающиеся значения, а по полученным координатам элементов прочитывать их 
и формировать поток. В любом случае (я склоняюсь к первому), сканирование теперь должно выполняться в ключевом индексе.

После загрузки и сканирования можно испытать и потом пора заняться доступом.

### 20220303 06:51

Провожу испытание первой чаксти реализации. Фактически, это испытание средств Polar.DB.

Проверил. Кое-что вспомнил, кое-что осознал или предположил. Например, последовательность ранее была фактически разбита на опорную последовательность и на 
индексы. В данной реализации, мы объединяем последовательность с индексами. Изменился и конструктор последовательности, в котором будет все что нужно. 

Теперь первично сделаю универсальный индекс.

Что-то начальное сваял, надо пробовать это оживить. Сначала поработаю с ключевым индексом, вставлю его определение в конструктор.

### 20220305 10:41
Надо двигаться дальше. Все пытаюсь собрать некоторый целостный начальный вариант. Какое-то время потратил на обдумывание методики включения универсального
индекса в обработку. Сомнения были относительно доступа к элементам по ключу. Общая форма предполагает использование образца, поэтому как правило,
надо конструировать искусственный образец и подавать массив. В общем, я с этой моделью свыкся и (пока) сделаю именно так.

Вернусь в универсальную последовательность. В ней будет один первичный индекс (primary key) и сколько-то других индексов. Начнем с первичного индекса.

С некоторыми трудностями, все же добился работу выдачи по ключу. Пока только очень локальной постановки. Надо проверить, что без загрузки тоже работает. 

Работает. Теперь попробую выявить потребительские свойства решения, попробую 1 млн. данных. 

### 20220306 11:49
Основной тест (загрузка, выборка) работает. Характеристики - не хуже, чем ожидалось. 

Что теперь? Надо расширять функциональность. В частности, надо добавить поиск по имени. И главное, надо сделать целостную систему 
редактирования. И еще, надо приделать получающееся решение в качестве движка к фактографическим системам. В общем, есть чем заниматься...
Кстати, есть еще "загадочный" третий файл, наверное, это шкала у индекса, но сейчас не время этим заниматься. 
Пожалуй, начну с первого пункта. Пора попробовать сделать движок.

### 20220308 13:20
В общем, дело оказалось не таким простым. Наверное, я мого чего забыл. Пришлось и вспоминать и преодолевать проблемы. Идея была и 
осталась в том, чтобы реализовать UniversalSequence и UniversalIndex по "лекалам" сформированным в разработке объектного подхода.
Создал проект, начал делать эти классы, в како-то момент, показалось что нужны изменения в уже сложившихся Polar.DB. Чего-то наваял, 
запутался... Пришлось начинать сначала, благо в репозитории есть та версия, с которой я начал. Со второй попытки что-то удалось 
сделать. Но поиск по Like не получился. Стал разбираться, понял (вспомнил), что этот доступ делается на основе общего компаратора
для строк с дополнительным использование компаратора like в момент организации поиска. В общем, сделал (вроде) начальный вариант 
универсальных классов. Пока это неизменяемые решения, построенные на базе UniversalSequenceBase, IndexKey32CompImmutable и
IndexViewImmutable. Можно двигаться дальше. 

Сделаю упрощенный вариант R-записи. И эти объекты упакую в последовательность. 

### 20220310 09:23
Ох как все непросто... Я закопался в вопросоах реализации универсальных последовательности и индекса. Из-за одной глупой ошибки
потерял кучу времени и написал много тестового кода. 

### 20220312 12:55
Добился работы протого теста последовательности перосон. Получил ожидаемые параметры. Теперь задумался об RDF. Набрел на мысль,
которая показалась катастрофической... Дело в том, что в имеющемся варианте основной процедуры поиска элемента по образцу,
видимо будет большое количество динамических действий. Каждое сравление с образцом будет выполняться долго. А ведь достаточно 
элементу сопоставить строковое значение критерия, потом легко будет производить поиск по базовому строковому Compare или по 
компаратору Like. 

В принципе, ситуация аналогична ситуации с выделением целочисленного хеш-ключа. Думаю, надо внести в новый индекс строковый ключ.
Есть смысл совместить этот вариант с векторым индексом. В конце концов поиск по имени порождает множественное отображение объект -> 
набор ключевых значений. Честно говоря, я не могу продумать все решение до конца, но думаю, все увяжется. И еще один момент. Ключ
можно объявить объектом, на котором есть метод ToCompare(). Но там могут возникнуть сложности с использованием строк...

Итак, как назвать новый индекс? Например: SVectorIndex. В нем будет последовательность строк и индексная последовательность к этой 
последовательности. Упорядочиваем лексикографически. При поиске допустимо применять like-компаратор. Попробую написать какой-нибудь 
код.





