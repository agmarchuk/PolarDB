### Проект Polar.OModel

Начинаю новый проект. Хочу попробовать целостно реализовать концепцию объектной модели последовательности, изложенной в [].
Буду использовать некоторые классы из Polar.DB, если проект получится, то перенесу его именно туда. Итак, начну прямо по тексту
статьи.

Последовательность - это набор объектов. В данном рассмотрении, объекты будут только одного вида: простой объект или массив объектов. 
Возможно, будет иметь смысл ввести тип, напр. RObject, но пока не буду этого делать. Второй момент - объекты предполагаются типизированными 
через систему типов Поляра, а последовательность будет набором элементов одного типа. Типизацию возмем из Polar.DB в виде объектов класса 
PType. Присоединю тот проект к этому. 

В качестве тестового и конкретизирующего материала, использую тип Person. В поляровской системе типизации, определение будет:
```
Person = {id: Int, name: Str, age: Int};
```
Сериализацию берем такой, которая сформирована. Естественно, в реализации баз данных, больше подходит бинарная сериализация. 
Я посмотрел, похоже, класс UniversalSequenceBase нам полностью подходит. Расширение этого класса добавит недостающие методы редактирования.
Итак, что у нас получается? Делаем конструктор, пока повторяющий конструктор базы


Добавляем через конструктор две функции
```
private Func<object, bool> isEmpty;
private Func<object, DateTime> timestamp;
```
Первая указывает на то, что элемент "пустой", т.е. вроде как отсуствующий. Вторая выдает отметку времени данного элемента. 

Далее, надо бы наметить реализацию ввода и сканирования. Уже на сканировании я споткнулся. 
В результирующий поток хотелось бы чтобы попадали последние варианты элементов. Намечу канву: 1) Есть компаратор (ключевой), определяющий
эквивалентноть элементов. 2) Среди эквивалентных элементов оригиналом является элемент с максимальной временной отметкой. 
Базовым решением является перебор элементов последовательности с проверкой является ли данный элемент оригиналом. Для этого, из взятого элемента
извлекается идентификатор, а по этому идентификатору выявляется является ли элемент тем самым. Если "тот самый элемент" имеет отметку пустого, то
он также не выдается в результирующий поток. Проблема данного алгоритма в том, что на каждый элемент базовой последовательности требуется производить поиск.
Можно поступить наоборот, сканировать индексный массив, причем только на отличающиеся значения, а по полученным координатам элементов прочитывать их 
и формировать поток. В любом случае (я склоняюсь к первому), сканирование теперь должно выполняться в ключевом индексе.

После загрузки и сканирования можно испытать и потом пора заняться доступом.

### 20220303 06:51

Провожу испытание первой части реализации. Фактически, это испытание средств Polar.DB.

Проверил. Кое-что вспомнил, кое-что осознал или предположил. Например, последовательность ранее была фактически разбита на опорную последовательность и на 
индексы. В данной реализации, мы объединяем последовательность с индексами. Изменился и конструктор последовательности, в котором будет все что нужно. 

Теперь первично сделаю универсальный индекс.

Что-то начальное сваял, надо пробовать это оживить. Сначала поработаю с ключевым индексом, вставлю его определение в конструктор.

### 20220305 10:41
Надо двигаться дальше. Все пытаюсь собрать некоторый целостный начальный вариант. Какое-то время потратил на обдумывание методики включения универсального
индекса в обработку. Сомнения были относительно доступа к элементам по ключу. Общая форма предполагает использование образца, поэтому как правило,
надо конструировать искусственный образец и подавать массив. В общем, я с этой моделью свыкся и (пока) сделаю именно так.

Вернусь в универсальную последовательность. В ней будет один первичный индекс (primary key) и сколько-то других индексов. Начнем с первичного индекса.

С некоторыми трудностями, все же добился работу выдачи по ключу. Пока только очень локальной постановки. Надо проверить, что без загрузки тоже работает. 

Работает. Теперь попробую выявить потребительские свойства решения, попробую 1 млн. данных. 

### 20220306 11:49
Основной тест (загрузка, выборка) работает. Характеристики - не хуже, чем ожидалось. 

Что теперь? Надо расширять функциональность. В частности, надо добавить поиск по имени. И главное, надо сделать целостную систему 
редактирования. И еще, надо приделать получающееся решение в качестве движка к фактографическим системам. В общем, есть чем заниматься...
Кстати, есть еще "загадочный" третий файл, наверное, это шкала у индекса, но сейчас не время этим заниматься. 
Пожалуй, начну с первого пункта. Пора попробовать сделать движок.

### 20220308 13:20
В общем, дело оказалось не таким простым. Наверное, я мого чего забыл. Пришлось и вспоминать и преодолевать проблемы. Идея была и 
осталась в том, чтобы реализовать UniversalSequence и UniversalIndex по "лекалам" сформированным в разработке объектного подхода.
Создал проект, начал делать эти классы, в како-то момент, показалось что нужны изменения в уже сложившихся Polar.DB. Чего-то наваял, 
запутался... Пришлось начинать сначала, благо в репозитории есть та версия, с которой я начал. Со второй попытки что-то удалось 
сделать. Но поиск по Like не получился. Стал разбираться, понял (вспомнил), что этот доступ делается на основе общего компаратора
для строк с дополнительным использование компаратора like в момент организации поиска. В общем, сделал (вроде) начальный вариант 
универсальных классов. Пока это неизменяемые решения, построенные на базе UniversalSequenceBase, IndexKey32CompImmutable и
IndexViewImmutable. Можно двигаться дальше. 

Сделаю упрощенный вариант R-записи. И эти объекты упакую в последовательность. 

### 20220310 09:23
Ох как все непросто... Я закопался в вопросоах реализации универсальных последовательности и индекса. Из-за одной глупой ошибки
потерял кучу времени и написал много тестового кода. 

### 20220312 12:55
Добился работы простого теста последовательности перосон. Получил ожидаемые параметры. Теперь задумался об RDF. Набрел на мысль,
которая показалась катастрофической... Дело в том, что в имеющемся варианте основной процедуры поиска элемента по образцу,
видимо будет большое количество динамических действий. Каждое сравление с образцом будет выполняться долго. А ведь достаточно 
элементу сопоставить строковое значение критерия, потом легко будет производить поиск по базовому строковому Compare или по 
компаратору Like. 

В принципе, ситуация аналогична ситуации с выделением целочисленного хеш-ключа. Думаю, надо внести в новый индекс строковый ключ.
Есть смысл совместить этот вариант с векторым индексом. В конце концов поиск по имени порождает множественное отображение объект -> 
набор ключевых значений. Честно говоря, я не могу продумать все решение до конца, но думаю, все увяжется. И еще один момент. Ключ
можно объявить объектом, на котором есть метод ToCompare(). Но там могут возникнуть сложности с использованием строк...

Итак, как назвать новый индекс? Например: SVectorIndex. В нем будет последовательность строк и индексная последовательность к этой 
последовательности. Упорядочиваем лексикографически. При поиске допустимо применять like-компаратор. Попробую написать какой-нибудь 
код.

### 20220314 21:34
Хотя и коряво, но разработка идет. Уже достиг реализации поиска элементов и базовой визуализации элементов. Только без обратных дуг.
Именно на этом я застопорился. Как-то потребность реализовать обратные отношения не укладываются в стройную схему объекной модели.
Суть можно пояснить тем, что индексация предполагает сортировку элементов и в этом отсортированном множестве - поиск подходящих
ЭЛЕМЕНТОВ. В лучшем случае, обратные отношения дадут по идентификатору записи, получить все записи, которые ссылаются на эту.
А вот по какому отношению идет объектная ссылка, в таком построении не просматривается. Хотя и можно вычислить. Хотя и не точно...
Дело в том, что модель RDF позволяет между двумя узлами иметь несколько разноименных стрелок. 

### 20220316 07:12
Все думаю насчет обратных ссылок. Можно сделать классически - добавить векторный индекс "узлов на себя". Недостатоком решения видится то,
что теряется информация о предикате обратной ссылки. А можно сделать графовое решение в смысле обратных ссылок, "встроенных" в узел. Как в 
первом расширении RRecord. Все равно эта информация должна присутствовать в индексном построении. Есть минимальная избыточность построения:
обратный предикат. Вообще, с предикатами надо бы поступать более экономно, чем сейчас. В конце концов, идентификаторов предикатов обычно
совсем немного. Может 256 значений не хватит, но 2^^32 - более, чем достаточно. Это всего 4 байта. 

Попробую проработать вариант с графом. Основной (первичный) индекс для графа: индекс по идентификатору сущности. Дополнительный индекс:
поиск по имени. Какая-то реализация этого есть. Теперь обратные ссылки. Подозреваю, что достраивать граф надо уже после его первичного 
построения. Хотя может и не так. 

Как произвести достраивание? Рассмотрим поток записей. Будем формировать множество троек { subj, pred, resource }. Это касается только 
объектных свойств. Далее, производится сортировка по ресурсам и т.д. Альтернатива для не слишком больших данных - хеш-словарь с ключом в виде 
ресурса. Третий вариант: последовательность с первичным ключем уже есть и мы добавляем пары { pred, subj } к множеству свойств записи с
идентификатором resource. Надо посмотреть как сейчас выполняется формирование множества записей. 

### 20220317 08:46
Я в больших сомнениях. Как-то плохо выстраивается вектрный индекс в объектную модель. И прямое встраивание в граф обратных отношений также
плохо встраивается. 

Начну с модели. Важно, что для векторного индекса наиболее существенной является функция, определенная на объектах последовательности и
вырабатывающая массив (поток) объектов (v-объектов). При этом формируется виртуальное или реальное множество пар 
{ v-объект, ссылка на объект }. Далее, ситуация сводится к универсальной последовательности. Соответственно, задаются хеш-функция, задается 
компаратор. Выполняются действия по поиску и выборке. 

Можно пока вывести векторный индекс из рассмотрения. Я просто сформирую поток (массив) объектных триплетов, потом сгуппируем их по ресурсу 
и сделаем хеш-словарь. Его будем использовать при построении графа. Как-то так...

### 20220320 15:14
С утра по телеку сказали, что сегодня - день весеннего равноденствия. Странно,.. раньше было 21-22-го. Ну да ладно, весна вступает в 
свои права!

Еще вчера я добилася некоторых результатов. Главное - сделал "стандартую" загрузку FillDb. Вставил сборку мусора и это значительно уменьшило 
использование ОЗУ. Теперь уже и trs-адаптер выглядит неплохим. om-адапетер работает пока в режиме визуализации. 

Надо бы доделать om, хотя я уже начал сомневаться в его необходимости. Тут главное - концепция редактирования. Она должна быть их Объектной
Модели. То есть, надо ввести поле isnull и надо внести временную отметку. Причем верменная отметка на этапе базы данных необязательна. Почему?
Дело в том, что множество записей разбивается на статическое и динамическое, причем оба множества содержат элементы в единственном экземпляре. 
Если элемент есть в динамическом наборе, то он приоритетен. Если производится замена на новую запись, то она замещает старую в динамическом 
наборе. С другой стороны, временная отметка не мешает и соответствует временной отметке в XML-элементах. 

В общем, администрирование записями довольно простое. Непростой является коррекция сопряженных записей. Добавление, изменение и уничтожение 
записи может приводить к изменению взаимосвязей по прямым и обратным ссылкам. Прямая ссылка: не было/появилась, была/изменилась, была/пропала.
Возможно, такая же номенклатура изменений имеется и для обратных ссылок. 

### 20220322 12:00
Я уже довольно далеко отклонился от объектной модели, надо возвращаться. Но для начала, попробую испытать блазор-решение в среде открытого 
архива на сервере fan. 

### 20220326 07:36
Испытания затянулись. Кажется, я даже что-то покорректировал, но все же темп продвижения был почти нулевым. Все же я выяснил, что основная 
характеристика, которая меня интересовала, использование оперативной памяти, ведет себя вполне приемлемо. Иногда лучше, чем хранилище 
триплетов trs, иногда хуже. 

Снова попробую вернуться к адаптеру om - объектной модели. Нужно добавить слабую динамику. Запланированный вариант заключается в том, чтобы
добавить хеш-словарь записей. Но до этого, запись расширить на два поля: булевское isnull и tS - временную отметку типа DateTime. В данный
набор будут собираться записи, которые изменились с некоторого момента времени, скорее всего, после последней загрузки. Логика построения в
том, что оригинал записи может находиться в основном (статическом) наборе или в динамическом наборе. Динамический набор безусловно более
приоритетный для определения "оригинальности". Если происходит изменение записи, то новая запись зафиксируется в динамическом наборе либо
в качестве нового элемента набора, если ее там не было, либо через изменнеие имеющегося. Также должны последовать изменения, связанные с 
коррекцией связей новой записи со старыми. Корректируются только эффекты, получившиеся из-за изменений прямых ссылок. Если прямая ссылка 
претерпела изменение, то 1) в расширенной записи на которую была ссылка, из обратных ссылок убирается ссылка на фокусный элемент. При этом,
элемент перемещается в динамический набор; 2) новое значение ссылки также корректирует список обратных ссылках ссылаемой записи путем
добавления ссылки на опорный элемент. Можно эти действия "разорвать" тем, что не допускать произвольных изменений, а разрешать только либо 
создание прямой ссылки, либо исчезновение. 

Теперь про поиск по имени. В принципе, это векторный индекс. Можно новые записи обрабатывать на предмет новых имен, старые имена не 
корректировать. Тогда все просто: появилась новая запись, выделаем набор новых имен, новые имена помещаем в таблицу {имя, идентификатор}.
Можно санчала проверить, что там этой пары нет. Поскольку таблица имен не чистится от уже не актуальных пар, то при поиске можно предполагать 
наличие не актуальных и надо проверять. В общем, это все. Пока... Попробую что-то написать.

Кстати сообразил, что в запись RRecord ПОКА можно не включать временную отметку. Временная отметка ПОКА пишется в fog-файлы и используется при
загрузке. А вот признак пустоты isnull, надо внедрять уже сейчас. Поэтому структурно я введу оба поля, а использовать пока буду только признак 
пустоты. А на первом шаге, просто введу поля и проверю, что все работает. 

Еще одна коррекция: признак пустоты можно вставить в поле Tp, напр. использумый delete. В принципе, это ничему не противоречит поскольку
в модели важно не поле, а функция. Так что, на первом шаге мы вообще обойдемся имеющейся структурой записи. Тем проще. Попытаюсь соорудить 
какую-то реализацию PutItem.

### 20220327 13:27
Дело движется, хотя и медлено. Сейчас отлаживаю цепочку "уничтожить айтем" - "найти айтем по имени". Айтем уничтожается, но вторая часть
по-прежнему его выдает. В принципе понятно, где проблема. Я неправильно написал вот это нахождение 
IEnumerable<XElement> SearchByName(string searchstring).

Фокус в том, что найденных в малом списке не надо искать в большом. Точнее среди найденных в большом списке (последовательности), надо убрать
те объекты, которые найдены в малом. Похоже нагляднее будет работать в терминах множеств. Из "большого" множества найденных надо вычесть "малое",
А потом их объединить. Фокус в том, что эквивалентность элементов устанавливается через идентификатор. Вроде должно сработать...

Вроде пробился через тонкости. Надо было учесть и два набора в поиске по имени и два набора (основной и динамический) в записях. 

Теперь буду работать над новым объектом. Новый объект начинается с записи, не имеющей связей с другими. 

### 20220329 15:13
Наконец, движок OmAdapter заработал. Ура!!! Даже сразу не соображу чем заниматься. Пока потратил время на отзхыв для Артема Плюснина. 
Теперь собираюсь перед лекцией. Наверное, начну с простого: побреюсь, сменю рубашку, намечу план лекции.

### 20220505 23:03
Вот решил немного порассуждать. Оказывается, я пару UniversalSequence и UniversalIndex еще не доделал. Смотрю и вижу дефекты в реализации. 

Начал с последовательности. В универсальной последовательности по имеющейся концепции нет динамической части. Это чистая последовательность. Растущая последовательность с идентифицированными элементами, с временной отметкой и признаком пустого элемента. Последовательность развивается слева направо в том смысле, что более "правые" элементы с одинаковым идентификатором имеют более поздние временные отметки. 

Один из важных методов для последовательности - выдача потока всех элементов. Теоретически, этот метод можно реализовать без индексов, но практически, лучше и эффективнее сделать с использованием первичного индекса. 

Рассмотрим структуру пары последовательность - первичный индекс. Предположим, последовательность сформирована в момент загрузки. При загрузке можно обеспечить (!) единственность элементов с уникальными идентификаторами, т.е. остаются только оригиналы значений. Из этого следует то, что в построенном (Build) первичном индексе есть только по одному элементу на каждый имеющийся уникальный идентификатор из последовательности. Добавление элемента в опорную последовательность сопровождается помещением его в первичный индекс, но в динамическую часть. Помещением под имеющимся идентификатором. Если в динамической части такой идентификатор уже есть, то такой элемент заменяется. Другой вариант - помещение офсета нового элемента вместо самого элемента. Не знаю в чем разница. 

В итоге получается, что идентификатор может быть в динамической части или только в статической. Рассмотрим генерацию потока элементов из последовательности. Берем элемент из опорной последовательности и смотрим, есть ли его идентификатор в динамической части. Если нет, то очевидно, данный элемент подходит для выдачи в поток. Если есть, то надо сравнить временную отметку и при совпадении, элемент выдавать в поток, при не совпадении, элемент не выдавать. В этом процессе видна разница в организации динамической части. В случае хранения самого элемента, надо сравнивать временную отметку. Но если в динамической части хранить офсет, то сравнивать надо только офсеты. На этом этапе временная отметка уже не нужна. Да и напряжение на ОЗУ меньше... Пустое значение в этом процессе не помеха, только надо проверять и в случае пустоты, просто не пропускать. Таким образом, выдача потока всех элементов последовательности можно организовать максимально эффективно. 

Базовых методов для последовательности два. Один - доступ к элементу через первичный ключ. 

###20220506 09:47
Другие доступы выполняются через универсальный индекс. Попробую напомнить себе как устроен универсальный индекс. Причем с учетом динамики. Универсальный индекс строится на основе компаратора и целочисленной хеш-функции. Он является последовательностью офсетов элементов, отсортированных по комбинации хэш-компаратор. То есть, за каждым элементом индекса имеется одни и только один элемент опорной последовательности. Почему только один? Потому что иначе будут одинаковые точки, которые не различимы и непонятно что обозначают. Поэтому векторный индекс не реализуется с помощью универсального индекса.

Структурно, индекс может также содержать целочисленнное значение хеш-функции, заданной на элементах. Обязатльно то, что массив универсального индекса должен быть отсортирован по этому  целочисленному значению. То есть, если хеш-функция задана, то сортировка сначала ведется по ней, а уже потом по компаратору. Поиск по индексу выявляет все элементы, которые соответствуют образцу, т.е. и хеш совпадает и компаратор указывает на одинаковость. 

Рассмотрим некоторую динамику. Опорная последовательность может изменяться через: добавление элемента, уничтожение элемента, изменение элемента. При добавлении элемента все предыдущие элементы остаются, значит все предыдущие элементы индекса также сохраняются. Появляются новые элементы индекса, теоретически (при уничтожении и модификации) какие-то элементы перестают быть актуальными. Появление новых элементов отследить легко, надо отрабатывать хендлер OnAddElement или OnUpdateElement. 






