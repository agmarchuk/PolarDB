## Task03_Polar.DB: Начинаем осваивать Поляр
В практической части данного курса будет использоваться библиотека работы с данными PolarDB или просто Поляр. Эта библиотека построена на небольшом количестве идей, принципов и решений, позволяет компактно и эффективно реализовывать специализированные построения.

Поляр построен на некотором представлении о типизации [], которое созвучно ряду других. Суть этого построения в том, что все рассматриваемые структурные объекты обладают внешним относительно себя типом и рассмотрение этих объектов корректно только в контексте его типа. В принципе, это как во многих других структурных построениях, напр. в C# можно написать оператор:
```
int[] arr = {1, 2, 3, 99};
```
При этом, int[] - определение типа структурного объекта, а справа имеется собственно структурный объект, точнее - его текстовое изображение, потому что в оперативной памяти, объект представляется по-другому. Мы можем изменить строчку на:
```
double[] arr = {1, 2, 3, 99};
```
И это уже будет совсем другая структура!

Альтернативой такому подходу является структуризация в так называемых "безтиповых" языках программирования, напр. в JavaScript. При таком подходе, тип присутствует, но он "встроен" в структурное значение.

Для лучшего понимания следующего материала, полезно будет познакомиться с элементами теории поляровской структуризации, см. Приложение А настоящего пособия. Можно не слишком досконально вчитываться в приложение, поскольку сами примеры будут вести понимание от простого к сложному.

Поработаем с тестовыми структурными значениями. В основном мы будем работать в среде .NET Core. Среда хороша в частности тем, что позволяет создавать эффективные решения, работающие под Windows, Linux и iOS. Библиотека Поляра для целей учебного курса доступна через Nuget пакеты набор DLL'ек, размещенных в директориях Resources\DLLs\PolarDBdlls\[Debug | Release]. На стадии обучения и осваивания, рекомендуется использовать группу Debug и в этом же режиме компилировать и исполнять задания. При испытаниях кода на производительность, можно вручную поменять библиотеки и режим на Release.

Начинаем формирование тестового кода. Заведем консольный проект .NET Core. Добавим ссылки на поляровские DLL'ки. Чтобы не требовалось указывать длинные имена, добавим используемые пространства имен:
```
using Polar.DB;
using Polar.Cells;
```
Еще важный момент - надо указать куда мы будем помещать файлы базы данных. В .NET Core, также как и ранее в .NET, рабочая директория по умолчанию совпадает с директорией где находится запускаемый EXE или DLL (через dotnet Prog.dll). Но если приложение запускается в "стандартном" режиме через Visual Studio или dotnet run, т.е. с использованием проектного файла, то именно место проектного файла является рабочей директорией. С учетом этого, определим path к директории будущей базы данных:
```
    string path = "../../Databases/";
```
Важным моментом является то, что все базы данных Поляра являются строго типизованными. Это означает, что сначала надо создать объект класса PType, определяющий тип (желаемую структуру) данных, а потом можно сформировать в виде файла ячейку хранения значений данного типа. Предположим, наша задача состоит в записи некоторого текста в виде ячейки базы данных. Тогда тип будет:
```
    PType tp = new PType(PTypeEnumeration.sstring);
```
Здесь написано, что формируется тип tp, определяющий простую (системную) строку. Системная строка – это строка (string), полностью совместимая с .NET.

Следующий шаг – создание собственно ячейки для хранения (в файловой системе) значения данного типа:
```
    PaCell cell = new PaCell(tp, path + "test.pac", false);
```
Параметры здесь означают следующее: tp – тип, второй параметр – path к файлу-ячейке (с обязательным расширением .pac), третий параметр определяет ячейку как изменяемую.

Теперь мы уже можем проверить некоторую работоспособность нашей программы (из двух операторов). При запуске программы, ничего нового выводиться не будет, однако, в директории Databases появится файл test.pac размером 32 байта. Это и есть Ваша база данных. 32 байта – некоторая служебная информация для ячейки. Последний из введенных операторов либо подключает Вашу программу к ячейке, если она есть, либо создает, если ее нет. Повторный запуск программы не произведет никаких изменений, поскольку теперь программа только подключится к test.pac.

Далее, записываем в ячейку данные заданного типа:
```
    cell.Fill("Привет из ячейки базы данных!");
```
Пропустив программу и посмотрев на файл с ячейкой, обнаруживаем, что он «подрос» - в нем теперь записаны данные. Если попробовать снова выполнить программу, то получится Exception с указанием на то, что ячейка не пуста. Дело в том, что Fill заполняет только пустую ячейку, Чтобы ее «опустошить» можно уничтожить файл и при следующем пропуске программы, заведется новая ячейка. Но лучше опустошить (очистить) ячейку применив оператор Clear(), который рекомендуется поставить перед Fill. Кроме того, добавим чтение данных из базы данных, получим очищение – запись – чтение:
```
    cell.Clear();
    cell.Fill("Привет из ячейки базы данных!");
    Console.WriteLine("Содержимое ячейки: {0}", cell.Root.Get());
```
Если все было нормально сделано, выскочит то содержимое ячейки, которое мы записали. Закомментарив очищение и заполнение, новым выполнением программы, мы убедимся, что данные по-прежнему извлекаются из ячейки.

Каждая ячейка предназначена для хранения значений определенного типа. До сих пор, мы работали только со строковым значением. Теперь рассмотрим использование записей, последовательностей и объединений, а также еще не рассмотренных атомарных типов. Создадим фрагмент вида:
```
    PType tp_rec = new PTypeRecord(
        new NamedType("имя", new PType(PTypeEnumeration.sstring)),
        new NamedType("возраст", new PType(PTypeEnumeration.integer)),
        new NamedType("мужчина", new PType(PTypeEnumeration.boolean)));
    object rec_value = new object[] { "Пупкин", 16, true };
    PaCell cell_rec = new PaCell(tp_rec, path + "test_rec.pac", false);
    cell_rec.Clear();
    cell_rec.Fill(rec_value);
    object from_rec = cell_rec.Root.Get();
    Console.WriteLine(tp_rec.Interpret(from_rec));
```
Здесь сначала определяется тип, представляющий собой запись из трех полей, строкового, целого и булевского типов. Потом определено константное значение rec_value, с конкретными значениями этих полей. Потом заполним ячейку этим значением, потом прочитаем в виде объекта значение, которое там хранится, потом интерпретируем прочитанное значение в контексте типа этого значения. Будет напечатано то, что вводилось, только в текстовом формате объектного представления. Подготовку объекта к печати в виде текста, осуществляет метод Interpret(v).

Для лучшего понимания того, что написано в данных фрагментах, приведу выдержку из документации, связанную с объектной формой представления (напр. rec_value) структурных значений:

Объектная форма представления структурных значений. Структурные значения или их части (в силу рекурсивности построения структурных значений) могут существовать в виде объектов системы программирования. Вид такого представления - самый общий, это object. Атомарные значения представляются в виде значений соответствующих системных типов или классов: bool, char, int, long, double. Строки представляются строками. Составные (конструируемые) значения представляются в виде массивов объектов object[]. Причем для записи, элементы массива соответствуют полям записи, для последовательности, элементы массива соответствуют элементам последовательности, для объединения - массив состоит из двух элементов. Первый имеет целочисленное значение и соответствует индексу тега, второй элемент массива соответствует подзначению объединения.

Итак, давайте сформируем более сложный тип, сформируем структурное значение, соответствующее этому типу, запишем значение в ячейку, т.е. в базу данных, потом прочитаем его из ячейки и распечатаем его в виде текста. Именно это мы делали в предыдущем фрагменте на примере простой записи. Будем работать с последовательностью записей. Соответственно, тип будет выглядеть:
```
    PType tp_seq = new PTypeSequence(tp_rec);
```
Мы воспользовались уже введенным типом tp_rec для того, чтобы определить последовательность записей. Объектное представление значения типа последовательности - массив объектов, представляющих записи. Пошлое значение объектного значения также будет расширено достаточно просто:
```
    object seq_value = new object[]
    {
        new object[] { "Иванов", 24, true },
        new object[] { "Петрова", 18, false },
        new object[] { "Пупкин", 22, true }
    };
    PaCell cell_seq = new PaCell(tp_seq, path + "test_seq.pac", false);
    cell_seq.Clear();
    cell_seq.Fill(seq_value);
    object from_seq = cell_seq.Root.Get();
    Console.WriteLine(tp_seq.Interpret(from_seq));
```
Решение совпадает с предыдущим один в один, с точностью до переименования. Но на этом решении обнаруживается ряд недостатков данного подхода. Главный - это не база данных, это хранилище отдельного структурного объекта. Мы его помещаем в ячейку, мы его извлекаем из ячейки. Но нет помещения по частям и извлечения по частям. Рассмотрим возможное решения задачи помещения по частям. Вот у нас в ячейке cell_seq есть три записи, а можно добавить четвертую? Можно. К PaCell последовательностям верхнего уровня применим метод добавления элемента AppendElement(r), где r - объектное представление добавляемого элемента. Эту часть реализуем как:
```
    cell_seq.Root.AppendElement(new object[] { "Сидоров", 23, true });
    Console.WriteLine(tp_seq.Interpret(cell_seq.Root.Get()));
```
Соответственно, можно частями (отдельными элементами) собрать уже большую последовательность, возможно не вмещающуюся в оперативную память. Теперь зададимся вопросом: как можно читать базу данных, в данном случае последовательность, по частям. Для ячеек реализован следующий подход: выделяется поле, в нем, если нужно выделяется подполе и т.д., в конце - производится выборка значения методом Get(). Методы выделения поля отличаются для разных составных типов. Для записи, это метод Field(nom), где nom - номер выделяемого поля, для последовательности, это метод Element(ind), где ind - номер выделяемого элемента, для объединения, это метод UElement(), дающий доступ к подэлементу. Есть еще получение свойств значений. Для последовательности, это метод Count(), дающий число элементов в последовательности, для объединения это метод Tag(), дающий текущий номер варианта типа для подзначения. Root - первичный выделитель, выделяющий все записанное значение.

Попрактикуемся на имеющейся последовательности из 4-х записей:
```
    long v0 = cell_seq.Root.Count();
    var v1 = cell_seq.Root.Element(2).Field(0).Get();
    var v2 = cell_seq.Root.Element(3).Field(1).Get();
    Console.WriteLine($"{v0} {v1} {v2}");
```
Важно понимать, что почти все простые значения (целые, логические и др.) фиксированного размера и только строки - нефиксированного. Все значения фиксированного размера можно замещать другими значениями. Это делается через выделение поля и применения метода Set(), напр.:
```
    cell_seq.Root.Element(1).Field(1).Set(19);
    cell_seq.Root.Element(1).Field(2).Set(true);
    Console.WriteLine(tp_seq.Interpret(cell_seq.Root.Get()));
```
